<pre>
  BIP: ?
  Layer: Applications
  Title: The Protocol of digital artifacts on dogecoin
  Status: Draft
  Type: Informational
  Created: 2023-05-08
  License: PD
</pre>

== Introduction ==

Dogecoin has no notion of stable, public accounts or identities. Addresses are
single-use, and wallet accounts are private. Additionally, the use of addresses
or public keys as stable identifiers precludes transfer of ownership or key
rotation. However, the digital artifacts need individual identities and allowing 
them to be tracked, transferred, and imbued with meaning. 

== Cardinals ==

The smallest indivisible unit in Dogecoin is defined as elon. One doge is equivalent to 100,000,000 elons.
Every sat is serially numbered, starting at 0, in the order in which it is
mined. These numbers are termed "cardinal numbers", or "cardinals", as they are
cardinal numbers in the mathematical sense, giving the order of each elon in the
totally supply. 

The cardinal numbers of elons in transaction inputs are transferred to output
elons in first-in-first-out order, according to the size and order of the
transactions inputs and outputs.

If a transaction is mined with the same transaction ID as outputs currently in
the UTXO set,  the new transaction outputs displace the older UTXO set entries, 
destroying the elons contained in any unspent outputs of the first transaction. 

For the purposes of the assignment algorithm, the coinbase transaction is
considered to have an implicit input equal in size to the subsidy, followed by
an input for every fee-paying transaction in the block, in the order that those
transactions appear in the block. The implicit subsidy input carries the
block's newly created elons. The implicit fee inputs carry the sats that were
paid as fees in the block's transactions.

Underpaying the subsidy does not change the ordinal numbers of sats mined
in subsequent blocks. Ordinals depend only on how many elons could have been
mined, not how many actually were.

Sats are numbered and transferred with the following algorithm:

<pre>
# subsidy of block at given height
def subsidy(height):
  return 50 * 100_000_000 >> height // 210_000

# first ordinal of subsidy of block at given height
def first_ordinal(height):
  start = 0
  for height in range(height):
    start += subsidy(height)
  return start

# assign ordinals in given block
def assign_ordinals(block):
  first = first_ordinal(block.height)
  last = first + subsidy(block.height)
  coinbase_ordinals = list(range(first, last))

  for transaction in block.transactions[1:]:
    ordinals = []
    for input in transaction.inputs:
      ordinals.extend(input.ordinals)

    for output in transaction.outputs:
      output.ordinals = ordinals[:output.value]
      del ordinals[:output.value]

    coinbase_ordinals.extend(ordinals)

  for output in block.transaction[0].outputs:
    output.ordinals = coinbase_ordinals[:output.value]
    del coinbase_ordinals[:output.value]
</pre>
